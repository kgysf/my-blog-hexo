<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="renderer" content="webkit"><meta name="theme-color" content="#FFFFFF"><title>Leetcode BFS相关题目笔记</title><link rel="stylesheet" href="/css/normalize.css"><link rel="stylesheet" href="/css/heti.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"><link rel="stylesheet" href="/css/hexo-theme-adoubi.css"><link rel="icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Xianyu's Note" type="application/atom+xml">
</head><body>
<script src="/js/axianyu.js"></script>
<div class="header"><a class="email-link" href="/"><span>Home</span></a><span class="header-center"></span><a class="email-link" href="mailto:master@uynex.com?subject=[Comment] About: Leetcode BFS相关题目笔记&amp;body=请在此处书写您的邮件内容; 请勿修改标题, 否则您的邮件可能会被收信规则屏蔽%0d%0a%0d%0a--------------------%0d%0aTitle: Leetcode BFS相关题目笔记%0d%0aUrl: http://blog.uremy.world/2022/01/leetcode-bfs-note/index.html%0d%0a"><span>Email</span></a><a class="subscribe-link" href="/2022/01/about/"><span>About</span></a></div><div class="content"><div class="post-item"></div><h2 class="post-title-wrapper"><p class="post-title">Leetcode BFS相关题目笔记</p></h2><div class="post-info"><span><time datetime="2022-01-12T02:04:35.000Z">2022-01-12</time></span><span class="header-center"></span><span class="license"><a href="#license">CC BY-NC-SA</a></span></div><div class="post-toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#752-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81-%E5%8F%8C%E5%90%91BFS"><span class="toc-number">1.</span> <span class="toc-text">#752 打开转盘锁 (双向BFS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">2.</span> <span class="toc-text">参考</span></a></li></ol></div><div class="post-content"><pre><code>菜鸟学习算法过程的笔记 - BFS
主要目的是记录一遍加深自己理解, 同时方便以后查阅
</code></pre>
<h3 id="752-打开转盘锁-双向BFS"><a href="#752-打开转盘锁-双向BFS" class="headerlink" title="#752 打开转盘锁 (双向BFS)"></a>#752 打开转盘锁 (双向BFS)</h3><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p>
<p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p>
<blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/open-the-lock">https://leetcode-cn.com/problems/open-the-lock</a>  </p>
</blockquote>
<p>四位初始值都为0的转盘锁, 每次只能旋转一位, 可以向上拨也可以向下拨, 那么在不考虑重复的情况下, 每次都有八种可能  </p>
<p>例如<code>&#39;0000&#39;</code>, 可以得出 <code>[&#39;0001&#39;, &#39;0010&#39;, &#39;0100&#39;, &#39;1000&#39;, &#39;0009&#39;, &#39;0090&#39;, &#39;0900&#39;, &#39;9000&#39;]</code>, 然后以上八组数字继续以此方式穷举下去, 可以建立一个hash表, 记录死亡数字和旋转过的组合</p>
<p>可以使用两个队列分别从<code>&#39;0000&#39;</code>和<code>target</code>开始穷举, 即双向bfs</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string[]&#125;</span> <span class="variable">deadends</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> openLock = <span class="function"><span class="keyword">function</span>(<span class="params">deadends, target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建deadSet, 同时在bfs中使用过的元素也会记录在deadSet中</span></span><br><span class="line">    <span class="keyword">const</span> deadSet = <span class="keyword">new</span> <span class="built_in">Set</span>(deadends);</span><br><span class="line">    <span class="keyword">return</span> bfs(deadSet, target, <span class="string">&#x27;0000&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Set&lt;String&gt;&#125;</span> <span class="variable">deadSet</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">initial</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bfs</span>(<span class="params">deadSet, target, initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (target === initial) &#123;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预防初始值在deadends中</span></span><br><span class="line">    <span class="keyword">if</span> (deadSet.has(initial)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 双向bfs, 两个队列分别从initial和target出发</span></span><br><span class="line">    <span class="keyword">let</span> queue1 = <span class="keyword">new</span> <span class="built_in">Set</span>([initial]);</span><br><span class="line">    <span class="keyword">let</span> queue2 = <span class="keyword">new</span> <span class="built_in">Set</span>([target]);</span><br><span class="line">    <span class="keyword">while</span> (queue1.size || queue2.size) &#123;</span><br><span class="line">        <span class="comment">// 遍历过程中不能直接修改队列, 会影响结果判断, 使用临时队列存储</span></span><br><span class="line">        <span class="keyword">const</span> queueTemp = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> current <span class="keyword">of</span> queue1) &#123;</span><br><span class="line">            <span class="comment">// 如果两个队列出现交集则返回step</span></span><br><span class="line">            <span class="keyword">if</span> (queue2.has(current)) &#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            deadSet.add(current);</span><br><span class="line">            <span class="comment">// 一共4位, 穷举每一位上拨与下拨的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 计算出上拨和下拨的值</span></span><br><span class="line">                <span class="keyword">let</span> [add, sub] = calc(current, j);</span><br><span class="line">                <span class="keyword">if</span> (!deadSet.has(add)) &#123;</span><br><span class="line">                    queueTemp.add(add);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!deadSet.has(sub)) &#123;</span><br><span class="line">                    queueTemp.add(sub);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交替队列遍历</span></span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = queueTemp;</span><br><span class="line">        step++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calc</span>(<span class="params">value, j</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> add = value.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> sub = value.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="comment">// 防止进位, 取余10获取个位</span></span><br><span class="line">    add[j] = (+value[j] + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 反拨等于正拨9次(如果用-1无法得到需要的结果)</span></span><br><span class="line">    sub[j] = (+value[j] + <span class="number">9</span>) % <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 也可以直接用join, 只是直接拼接能快20ms左右, 纯粹是为了快这20ms (qwq</span></span><br><span class="line">    add = <span class="string">&#x27;&#x27;</span> + add[<span class="number">0</span>] + add[<span class="number">1</span>] + add[<span class="number">2</span>] + add[<span class="number">3</span>];</span><br><span class="line">    sub = <span class="string">&#x27;&#x27;</span> + sub[<span class="number">0</span>] + sub[<span class="number">1</span>] + sub[<span class="number">2</span>] + sub[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">return</span> [add, sub];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行用时: 180 ms<br>内存消耗: 47.6 MB<br>提交结果地址: <a target="_blank" rel="noopener" href="https://leetcode-cn.com/submissions/detail/257262250/">https://leetcode-cn.com/submissions/detail/257262250/</a></p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/leetbook/read/queue-stack/kyozi/">队列和 BFS</a></p>
</div><div class="post-tags"><h3>Tags</h3><i><a href="/tags/leetcode">#leetcode</a></i><i><a href="/tags/bfs">#bfs</a></i></div><a name="license"></a><div class="cc-license"> <div class="cc-post-title">Leetcode BFS相关题目笔记</div><div class="cc-post-url"><a href="http://blog.uremy.world/2022/01/leetcode-bfs-note/">http://blog.uremy.world/2022/01/leetcode-bfs-note/</a></div><div class="cc-post-detail"> <span class="cc-post-detail-item cc-post-detail-author"><div class="cc-post-detail-item-title"> 本文作者</div><div class="cc-post-detail-item-value">咸鱼</div></span><span class="cc-post-detail-item cc-post-detail-date"><div class="cc-post-detail-item-title"> 发布时间</div><div class="cc-post-detail-item-value">2022-01-12</div></span><span class="cc-post-detail-item cc-post-detail-license"><div class="cc-post-detail-item-title"> 许可协议</div><div class="cc-post-detail-item-value"><a class="cc-license-name" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a></div></span></div><div class="cc-post-desc">本文采用 [CC 署名-非商业性使用-相同方式共享 4.0] 协议, 转载或引用本文时请遵守许可协议!</div></div><script>var postInfo = { 
    license: 'CC BY-NC-SA 4.0',
    author: '咸鱼',
    url: 'http://blog.uremy.world/2022/01/leetcode-bfs-note/',
}</script><div id="pagination"><div class="post-pagination"><div class="next-post pull-right"><div class="post-pageurl"><a href="/2022/01/hexo-action-deploy/"><span>迁移Hexo+Action自动部署时遇到的问题记录</span><i class="fa fa-chevron-right"></i></a></div></div></div></div></div><div class="footer"><div class="footer-copyright">Theme By <a target="_blank" rel="noopener" href="https://github.com/kgysf/hexo-theme-axianyu">Axianyu</a> , Powered By Hexo.</div></div></body></html>