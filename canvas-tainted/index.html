<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="renderer" content="webkit"><meta name="theme-color" content="#FFFFFF"><title>HTML5画布污染(Tainted Canvases)问题</title><link rel="stylesheet" href="/css/normalize.css"><link rel="stylesheet" href="/css/heti.min.css"><link rel="stylesheet" href="/css/hexo-theme-adoubi.css"><link rel="icon" href="/images/favicon.ico"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Xianyu's Note" type="application/atom+xml">
</head><body><div class="header"><a class="email-link" href="/"><span>Home</span></a><span class="header-center"></span><a class="email-link" href="mailto:master@uynex.com?subject=[Comment] About: HTML5画布污染(Tainted Canvases)问题&amp;body=请在此处书写您的邮件内容; 请勿修改标题, 否则您的邮件可能会被收信规则屏蔽%0d%0a%0d%0a--------------------%0d%0aTitle: HTML5画布污染(Tainted Canvases)问题%0d%0aUrl: http://blog.uremy.world/canvas-tainted/index.html%0d%0a"><span>Email</span></a><a class="subscribe-link" href="/about"><span>About</span></a></div><div class="content"><div class="post-item"></div><h2 class="post-title-wrapper"><p class="post-title">HTML5画布污染(Tainted Canvases)问题</p></h2><div class="post-date"><time datetime="2018-11-08T12:32:23.000Z">2018-11-08</time></div><div class="post-content"><p>上一篇文章记录了JS实现HTML元素截图，最后生成的截图是绘制在canvas上，然后用户右键复制或者保存图片; 如果需要放在a标签中点击下载，那么需要用到canvas的toDataURL方法，但是这个时候会抛出一个异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught DOMException: Failed to execute &#x27;toDataURL&#x27; on &#x27;HTMLCanvasElement&#x27;: Tainted canvases may not be exported.</span><br></pre></td></tr></table></figure>


<p>这是因为画布被<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_enabled_image#%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E2%80%9C%E8%A2%AB%E6%B1%A1%E6%9F%93%E2%80%9D%E7%9A%84_canvas">污染</a>了，浏览器安全策略不允许被污染的画布使用toDataURL等函数。而大部分相关问题的搜索结果中，几乎都是给img设置crossOrigin属性，并且获取资源的服务器设置允许跨域。尝试过后无法解决。</p>
<p>于是继续搜索，然后在stackoverflow上找到了一个和我情况一样的提问，解决办法如下（在上一篇文章的js代码中修改）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分重复代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要将svg转为blob，也不需要根据blob创建url对象，直接将svg转为base64</span></span><br><span class="line"><span class="keyword">const</span> b64 = <span class="string">&quot;data:image/svg+xml;base64,&quot;</span> + <span class="built_in">window</span>.btoa(data);</span><br><span class="line"></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img.src = b64;</span><br></pre></td></tr></table></figure>

<p>如果你截图的部分不包含汉字之类的特殊字符，那么这之后你应该可以正常使用toDataURL方法了，但是我的页面中包含中文字符，于是又抛出了下面这个异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to execute &#x27;btoa&#x27; on &#x27;Window&#x27;: The string to be encoded contains characters outside of the Latin1 range.</span><br></pre></td></tr></table></figure>

<p>这个是因为浏览器自带的btoa方法不支持将中文转为base64, 以下是来自<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/btoa">MDN</a>的描述:  </p>
<blockquote>
<p>Note: 由于这个函数将每个字符视为二进制数据的字节，而不管实际组成字符的字节数是多少，所以如果任何字符的码位超出 0x00 ~ 0xFF 这个范围，则会引发 InvalidCharacterError 异常。请参阅 Unicode_字符串 ，该示例演示如何编码含有码位超出 0x00 ~ 0xFF 范围的字符的字符串。</p>
</blockquote>
<p>解决办法是使用第三方的Base64库，我使用的<code>js-base64</code>，使用npm来安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save js-base64</span><br></pre></td></tr></table></figure>

<p>然后引入js-base64</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Base64 &#125; <span class="keyword">from</span> <span class="string">&#x27;js-base64&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然后将上面代码中的<code>window.btoa(data)</code>替换为<code>Base64.encode(data)</code>即可。</p>
<p>关于<code>js-base64</code>的具体使用方法请参考npm上的文档：<a href="https://www.npmjs.com/package/js-base64">js-base64</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_enabled_image#%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E2%80%9C%E8%A2%AB%E6%B1%A1%E6%9F%93%E2%80%9D%E7%9A%84_canvas">MDN 安全性和“被污染”的 canvas</a><br><a href="https://www.npmjs.com/package/js-base64">NPM js-base64</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/btoa">MDN btoa</a></p>
</div></div><div class="footer"><div class="footer-copyright">Theme By <a href="https://github.com/kgysf/hexo-theme-axianyu">Axianyu</a> , Powered By Hexo.</div></div></body></html>